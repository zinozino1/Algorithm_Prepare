```py

****** DFS & BFS

0) 상태트리
-> 실제로 존재하는 트리가 아님 문제에 맞게 트리를 정의해줘야한다.

1) DFS

2) BFS

-> DFS와 달리 상태트리의 레벨을 체크하기 쉽지 않으므로 레벨체크 배열이 필요함
-> 레벨탐색이므로 L값이 꼭 필요함
-> BFS는 무조건 레벨!!!!



****** 실전Tip

0) 공통

-> dfs의 인자로 들어간 값은 각 가지마다 다른 값으로 쓰이므로 전역으로 못쓴다 ex) tot, sum, cnt 등등
-> 하지만 check배열 처럼 dfs외부에 선언되는 것은 모든 가지에 공통으로 쓸 수 있음 이 경우 backtracking을 할 때 적절히 넣고 뺴는 것이 중요함


1) 부분집합

-> 대부분의 문제
-> n지선다로 가지를 뻗어나갈 수 있음(ex: 포함 or 포함x, a가먹는다 or b가먹는다 or c가먹는다)
-> dfs 인자 L로 선정 : 다음단계 들어갈 때 L+1로 실행
-> 경우에 따라 check배열(카운팅) 필요.
-> 종료조건은 보통 L == n
-> 중복 x 모든 경우의수임 : 조합의 상위버전. 데이터가 3개면 3C1 + 3C2 + 3C3의 결과를 낼 수 있음



2) 순열

-> 데이터의 갯수만큼 가지를 뻗는다.
-> dfs 인자 i(반복문 인덱스)로 설정, 경우에 따라 L(레벨)로 설정가능
-> 중복순열을 피하려면 check 중복체크배열 필요 check 배열을 두면 종료조건이 없어도 순열 순회 가능 이때는 팩토리얼 개념
-> 종료조건을 명시적으로 둔다면 4P2, 4P3과 같이 permutation 개념으로 활용가능



3) 조합

-> 데이터의 갯수만큼 가지를 뻗는다.
-> dfs 인자 i(반복문 인덱스)로 설정, 경우에 따라 L(레벨)로 설정가능
-> 중복을 피하기위해 반복문의 index를 제한으로 둠, check배열 필요 없음 index를 제한으로 두면 종료조건이 없어도 됨 이때는 부분집합과 같은 개념
-> 종료조건을 명시적으로 둔다면 4C2, 4C3과 같이 combination 개념으로 활용가능


* 테크닉

1) 건너뛰는 테크닉

-> 특정 조건을 만족한 경우 레벨을 건너뛸 수 있음. 그때의 상태트리 잘 파악해야함.



```
