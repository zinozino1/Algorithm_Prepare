```py

* 이진 탐색

오름차순으로 정렬된 배열에서 원하는 숫자(target)을 찾는 알고리즘.

1) 배열 전체의 중간값을 target 값과 비교
2) 중간값이 target 값보다 크면 왼쪽 부분만 선택
3) 왼쪽부분의 중간값을 다시 target 과 비교

정방향으로 푸는 방법과 재귀로 푸는 방법 두 가지가 있음
정방향도 어떻게 보면 개념적으로는 재귀로 푸는 방법과 같은 방법.

def binary_search(a, t):
    a.sort()
    n = len(a)
    l = 0
    r = n - 1

    while l < r:
        m = (l + r) // 2
        if a[m] == t:
            return m
        elif a[m] > t:
            r = m - 1
        else:
            l = m + 1
    return -1


** 내장 라이브러리 bisect

bisect.bisect() 로 쉽게 구현 가능




*** 파라메트릭 서치(Parametric Search)

-> 이진 탐색과 매우 유사
-> 최적화 문제를 결정문제로 바꾸어 풀 수 있음
-> 알고리즘에서 이진 탐색을 사용한다는 것은 거의 대부분이 파라메트릭 서치를 사용하는 것임


******** Tip

* 결정 문제로 바꾸는 것이 매우 중요하다.

ex) 길이를 5로 설정했을 때 말 3마리가 들어가거나 더 많이 들어가니 아니면 3마리 보다 적게 들어가니?
-> 3마리라는 입력 값에 얽매이지 말고 3마리 이상? 3마리 미만? 이렇게 생각하자

ex2) 최대 시간을 17분으로 설정했을 때 3개의 뮤직비디오가 들어가거나 더 많이 들어가니 아니면 3개보다 적게 들어가니?
-> 마찬가지.

* 약간 유형이 다르다 -> 하지만 핵심은 동일
1) 합 - 랜선 자르기, 나무 자르기 -> return sum
2) 갯수 - 뮤직 비디오, 마굿간 결정 -> return cnt

* 대개
5 10 = n, m
20 15 35 20 40 이렇게 주어졌을 때 m을 중심으로 < ? > ? 이렇게 판단 한다.

*  lt, rt 설정 하는 거 배열 없이 그냥 설정 왜냐면 range 처럼 연속된 숫자이므로 max 또는 min 만 있으면 된다.



***** capa가 무조건 중요함

-> 1. 일단 이분탐색의 범위는 문제에서 요구하는 값의 범위로 설정.
-> 2. while 문에서 도출된 capa값(mid)을 헬퍼메서드에서 야무지게 요리하여 답을 도출해내야함(보통 return cnt or sum 으로 while 문 안에 박는다). capa는 이분탐색 범위 값중 하나이며, 나중에 m값과 비교를 통해 capa를 조절해야함.
-> 3. 헷갈리므로 일단 외워버리기




** 그리디 알고리즘

-> 단계에서 제일 좋은 것 선택 보통의 그리디 문제는 보통 정렬가 동반되어서 문제 풀이됨
-> 최적화 문제에서 최대값, 최소값을 찾음. 현재 상태에서의 최적 값을 선택해나가는 것을 반복(local optimum)
-> 모든 경우의 수를 고려한 최적해를 구하지 못할 수도 있음. 빠르게 근사해를 구할 떄는 유용함.
-> 최단경로(프림, 크루스칼, 다익스트라, 최소비용신장트리) 문제가 그리디 인듯?
-> 특정한 상황에 있어서는 최적의 해를 보장할 수도 있다.-> 이걸 판단하기가 빡세긴함


* 이분탐색 vs 그리디
-> 뭔가 문제 읽어보면 비슷한 것 같지만 그리디는 좀 더 조건이 복잡한 것 같음
이분탐색은 뭔가 조건이 연속적이고 파악하기가 약간 더 쉬운 것 같다. + 이분탐색은 소팅하기 어렵거나 못함. 반면에 그리디는 거의 무조건 소팅 할 수 있음. + 이분탐색의 경우 m(이분탐색 범위)가 와 닿음 => 충분히 크다할 수 있음 + m이 답과 직결됨

* 완전탐색 vs 그리디
-> 계산해야하는 리스트 갯수가 심각하게 크면 그리디일 가능성 99%


** 그리디
-> 정당성 증명이 필요함(근사해 or 최적해)
-> 예를 들어 동전 거스름돈 문제에서 그리디를 적용하려면 각 동전들이 서로의 약수/배수여야함. 그렇지 않으면 최적해를 보장하지 못함 따라서 완전탐색으로 풀어야한다.

```
