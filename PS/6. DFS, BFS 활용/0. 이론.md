```py

****** DFS & BFS

0) 상태트리
-> 실제로 존재하는 트리가 아님 문제에 맞게 트리를 정의해줘야한다.

1) DFS
-> 송곳 : 끝까지 갔다가 백트래킹 후 다시 끝까지 가는 형태
2) BFS
-> 동심원 : 서서히 물들여간다
-> while, for 가 헷갈린다면 상태트리를 그려보자.

3) 격자탐색
-> 격자에서 상하좌우로 연결되어 있는 집합들을 찾는 스타일의 문제 즉 한지점에서 시작하여 퍼저나가는 스타일(블러드 필)은 BFS, DFS 둘 중 아무거나 쓸 수 있다. 하지만 격자에서 여러 경로를 찾는 문제는 DFS를 써야 하고, 격자에서 최단거리 탐색을 할 때는 BFS를 써야 함
* 블러드필 : DFS,BFS -> DFS가 더 좋은듯?
* 최단거리탐색 : BFS
* 경로의 수 : DFS

****** 실전Tip

* DFS

0) 공통

-> dfs의 인자로 들어간 값은 각 가지마다 다른 값으로 쓰이므로 전역으로 못쓴다 ex) tot, sum, cnt 등등
-> 하지만 check배열 처럼 dfs외부에 선언되는 것은 모든 가지에 공통으로 쓸 수 있음 이 경우 backtracking을 할 때 적절히 넣고 뺴는 것이 중요함


1) 부분집합

-> 대부분의 문제
-> n지선다로 가지를 뻗어나갈 수 있음(ex: 포함 or 포함x, a가먹는다 or b가먹는다 or c가먹는다)
-> dfs 인자 L로 선정 : 다음단계 들어갈 때 L+1로 실행
-> 경우에 따라 check배열(카운팅) 필요.
-> 종료조건은 보통 L == n
-> 중복 x 모든 경우의수임 : 조합의 상위버전. 데이터가 3개면 3C1 + 3C2 + 3C3의 결과를 낼 수 있음



2) 순열

-> 데이터의 갯수만큼 가지를 뻗는다.
-> dfs 인자 i(반복문 인덱스)로 설정, 경우에 따라 L(레벨)로 설정가능
-> 중복순열을 피하려면 check 중복체크배열 필요 check 배열을 두면 종료조건이 없어도 순열 순회 가능 이때는 팩토리얼 개념
-> 종료조건을 명시적으로 둔다면 4P2, 4P3과 같이 permutation 개념으로 활용가능



3) 조합

-> 데이터의 갯수만큼 가지를 뻗는다.
-> dfs 인자 i(반복문 인덱스)로 설정, 경우에 따라 L(레벨)로 설정가능
-> 중복을 피하기위해 반복문의 index를 제한으로 둠, check배열 필요 없음 index를 제한으로 두면 종료조건이 없어도 됨 이때는 부분집합과 같은 개념
-> 종료조건을 명시적으로 둔다면 4C2, 4C3과 같이 combination 개념으로 활용가능


4) 테크닉

건너뛰는 테크닉

-> 특정 조건을 만족한 경우 레벨을 건너뛸 수 있음. 그때의 상태트리 잘 파악해야함.

5) 최단거리탐색 ex)행렬 미로 같은 것

-> 경로의 가지 수를 파악하는 데 유용


* BFS

1) while q: 형태로 대부분 풀이 가능.
-> 종료조건(대개 n번째 탐색에서 끊는 종료조건이 많음)이 있을 경우 break 걸어서 끊어줌

2) 항상 레벨이 중요

-> 각 레벨은 n번 시도했을 떄를 뜻한다.

3) 최단거리의 문제는 대부분 BFS?

4) 최단거리탐색 ex)행렬 미로 같은 것

-> 최단경로(거리)를 파악하는 데 유용


```
