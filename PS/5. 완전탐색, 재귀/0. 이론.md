```py

1. 재귀함수 & DFS

-> 스택을 활용하여 작동
-> 반복문의 대체제
-> 종료조건이 있어야함.
-> call stack 잘 파악해야함.

-> DFS 잘 하려면
* 상태트리 정의를 잘 해야함. (백트래킹?)

* DFS -> 대표적으로 백트래킹에 사용된다.


****
DFS와 Backtracking

1) DFS : 완전 탐색을 기본으로 하는 그래프 순회 기법으로, 모든 노드를 방문하는 것을 목표로 한다.

2) Back-tracking : 불필요한 탐색을 하지 않고, 이전 단계로 돌아와 다른 후보해를 탐색해 나가는 방법

=> 일단 가보고 후보해가 될 수 없으면 다음 단계로 진행하지 않고 되돌아 나온다.


DFS와 Back-tracking 둘다 재귀 호출 형태로 자주 구현이 되기 때문에 헷갈린다.

두 알고리즘은 사용 목적에 차이가 있다.



* DFS : 깊이 우선 탐색하여 모든 노드를 방문하는 것을 목표로 한다.
* Backtracking : 불필요한 탐색을 하지 않기 위해, 유망하지 않은 경우의 수를 줄이는 것을 목표로 한다.


DFS는 완전 탐색을 목표로 하는 알고리즘이기 때문에 자원 소모가 굉장히 심하다. 그래서 어떤 제약 조건에 맞는 해답을 찾기 위해서 DFS와 Back-tracking 기법을 혼용해서 사용한다.

=> 가지 치기를 통해서 얻은 그래프에 대해서 다시 DFS 탐색을 하면서 불필요한 탐색을 줄여 나간다.



******Tip


0) 순열, 중복순열, 조합, 중복조합

-       중복 비허용   중복 허용
순서고려    순열       중복순열
순서무시    조합       중복조합

** 공통 - 뽑는 갯수를 Level(depth)로 둔다, 결과 출력할 res 배열 필요

* 순열 - 같은숫자 중복피하는 check배열 필요
* 중복순열 - 그냥 하면 됨
* 조합 - 순서무시하므로 반복문 인덱스 조정 필요 * s, 같은숫자 중복피하는 check배열 필요
* 중복조합 - 같은숫자 중복피하는 check배열 필요


1)

dfs(x*2)
dfs(x*2+1)
형태면 실 배열을 사용하는 것

dfs(x+1)
dfs(x+1)
형태면 상태공간트리를 사용하는 것 (check 배열과 같은 공간 사용하여)
-> 동일한 인덱스를 재귀호출하므로 루트의 서브트리는 같은 값을 가리키고
-> 같은 값은 어떤 로직에 의해 분기된다.(ex) 포함되냐 안되냐~...

2)

* 부분집합을 모두 출력하는 형태면 helper 공간 필요(check배열 같은)
* 부분집합의 연산값(합 등)을 출력하는 형태면 helper 공간 필요 x -> dfs인자에 sum 같은 변수 넣을 것

3) ******

* 중복된 연산이 필요한 경우(대부분 순열) -> 뭘 넣냐를 정의. (순열 - 중복순열, 중복x순열=>(check배열 통해 가지치기 가능))
* 중복된 연산이 아닐 경우(대부분 부분집합) -> 넣냐 넣지 않느냐를 정의.(보통 모든 부분집합 출력)(부분집합)

4)

* 중복 o -> 뭘 넣냐 (순열)
- sum : 동전교환
- check : 중복순열

* 중복 x -> 넣냐 넣지 않느냐 (부분집합)
- sum : 바둑이, 합이 같은 부분집합
- check : 부분집합

5) 순서를 지키려면
check[L] = i 와 같이 체크 배열 인덱스 컨트롤을 잘 해야함

6)
dfs 위에 있으면 가지 뻗어나가면서 하는 작업
dfs 아래에 있으면 다시 돌아오면서 하는 작업

7)
helper 배열 정의가 매우 중요..
ex 순열값 저장 배열, 가지치기용 배열, 수학적 트릭을 위한 배열 등

***** 전역변수와 지역변수 잠깐


def dfs():
    cnt = 3  # 지역
    print(cnt)


def dfs2():
    global cnt # 이렇게 선언하면 밑에 다 해 결
    if cnt == 5: # 밑에 문장 때문에 오류 발생
        cnt = cnt + 1  # error 지역 변수를 새로 만든 것. 새로 할당하면 전역변수 사용불가
        print(cnt)


if __name__ == "__main__":
    cnt = 5  # 전역
    dfs()
    dfs2()
    print(cnt)


*

def dfs():
  a[0]=7 # 이건 잘 작동.
  a = [4,5,6] # 이건 로컬리스트를 만든 것.
  print(a)

if __name__=="__main__":
  a=[1,2,3]
  dfs()
  print(a)


```
