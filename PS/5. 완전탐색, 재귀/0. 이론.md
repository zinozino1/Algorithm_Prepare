```py

1. 재귀함수 & DFS

-> 스택을 활용하여 작동
-> 반복문의 대체제
-> 종료조건이 있어야함.
-> call stack 잘 파악해야함.

-> DFS 잘 하려면
* 상태트리 정의를 잘 해야함. (백트래킹?)

* DFS -> 대표적으로 백트래킹에 사용된다.


****
DFS와 Backtracking

1) DFS : 완전 탐색을 기본으로 하는 그래프 순회 기법으로, 모든 노드를 방문하는 것을 목표로 한다.

2) Back-tracking : 불필요한 탐색을 하지 않고, 이전 단계로 돌아와 다른 후보해를 탐색해 나가는 방법

=> 일단 가보고 후보해가 될 수 없으면 다음 단계로 진행하지 않고 되돌아 나온다.


DFS와 Back-tracking 둘다 재귀 호출 형태로 자주 구현이 되기 때문에 헷갈린다.

두 알고리즘은 사용 목적에 차이가 있다.



* DFS : 깊이 우선 탐색하여 모든 노드를 방문하는 것을 목표로 한다.
* Backtracking : 불필요한 탐색을 하지 않기 위해, 유망하지 않은 경우의 수를 줄이는 것을 목표로 한다.


DFS는 완전 탐색을 목표로 하는 알고리즘이기 때문에 자원 소모가 굉장히 심하다. 그래서 어떤 제약 조건에 맞는 해답을 찾기 위해서 DFS와 Back-tracking 기법을 혼용해서 사용한다.

=> 가지 치기를 통해서 얻은 그래프에 대해서 다시 DFS 탐색을 하면서 불필요한 탐색을 줄여 나간다.



******Tip

1)

dfs(x*2)
dfs(x*2+1)
형태면 실 배열을 사용하는 것

dfs(x+1)
dfs(x+1)
형태면 상태공간트리를 사용하는 것 (check 배열과 같은 공간 사용하여)
-> 동일한 인덱스를 재귀호출하므로 루트의 서브트리는 같은 값을 가리키고
-> 같은 값은 어떤 로직에 의해 분기된다.(ex) 포함되냐 안되냐~...

2)

* 부분집합을 모두 출력하는 형태면 helper 공간 필요(check배열 같은)
* 부분집합의 연산값(합 등)을 출력하는 형태면 helper 공간 필요 x -> dfs인자에 sum 같은 변수 넣을 것


***** 전역변수와 지역변수 잠깐


def dfs():
    cnt = 3  # 지역
    print(cnt)


def dfs2():
    global cnt # 이렇게 선언하면 밑에 다 해 결
    if cnt == 5: # 밑에 문장 때문에 오류 발생
        cnt = cnt + 1  # error 지역 변수를 새로 만든 것. 새로 할당하면 전역변수 사용불가
        print(cnt)


if __name__ == "__main__":
    cnt = 5  # 전역
    dfs()
    dfs2()
    print(cnt)


*

def dfs():
  a[0]=7 # 이건 잘 작동.
  print(a)

if __name__=="__main__":
  a=[1,2,3]
  dfs()
  print(a)


```
