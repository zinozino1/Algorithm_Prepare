```py

1. 스택

-> LIFO 구조 나중에 들어간 것이 먼저 나온다.

0) init
-> stack = []
1) push
-> stack.append(num)
2) pop
-> a = stack.pop() or stack.pop()
3) peek
-> a = stack[-1]

** 팁

-> 한꺼번에 넣고 생각하지말고 하나씩 넣어보며 조건 판단해보기.
-> 뭔가 연속된 데이터를(연결된 데이터?) 조건에 맞게 차례로 넣을 때 쓸 수 있다.


2) 큐

-> 큐(queue)는 선입선출, FIFO(First In First Out) 기반의 매우 유명한 자료 구조. 큐를 사용하면 데이터를 추가한 순서대로 제거할 수 있기 때문에 스트리밍(streaming), 너비 우선 탐색(breath first search) 에 유용하게 사용할 수 있음

* 파이썬에서 큐 사용방법

1- list

-> enqueue : 뒤 - append() 앞 - insert(0, x)
-> dequeue : 뒤 - pop() 앞 - pop(0)
-> 뒤 : o(1) 앞 : o(N)
-> 한 칸 뒤로 밀어야하기때문
-> 성능면에서 사용하지 않는 것이 좋음. pop(0)과 insert(0, x)는 o(N)이므로 비효율적

2- deque (double-ended queue)

-> collections 모듈의 자료구조.
-> 양방향에서 데이터를 추가하고 제거할 수 있음

-> enqueue : 뒤 - append() 앞 - appendleft()
-> dequeue : 뒤 - pop() 앞 - popleft()
-> 뒤 : o(1) 앞 : o(1)
-> popleft(), appendleft() 는 o(1)이므로 성능대비 이점이 있음


3) 해시

-> 키(Key)와 값(Value)쌍으로 이루어진 데이터 구조를 의미합니다. Key를 이용하여 데이터를 찾으므로, 속도를 빠르게 만드는 구조입니다.
파이썬에서는 딕셔너리(Dictionary) 타입이 해쉬 테이블과 같은 구조입니다.
기본적으로는, 배열로 미리 Hash Table 크기만큼 생성해서 사용합니다. 공간은 많이 사용하지만, 시간은 빠르다는 장점이 있습니다.
검색이 많이 필요한 경우, 저장, 삭제, 읽기가 많은 경우, 캐쉬를 구현할 때 주로 사용됩니다.

* 장점
데이터 저장/검색 속도가 빠릅니다.
해쉬는 키에 대한 데이터가 있는지(중복) 확인이 쉽습니다.

* 단점
일반적으로 저장공간이 좀더 많이 필요합니다.
여러 키에 해당하는 주소가 동일할 경우 충돌을 해결하기 위한 별도 자료구조가 필요합니다. (충돌 해결 알고리즘)

* 시간 복잡도
일반적인 경우(충돌이 없는 경우): O(1)
최악의 경우(모든 경우에 충돌이 발생하는 경우): O(n)

***** 해시는 키 값이 같은 경우 값을 덮어쓴다는 점이 중요. 이를 활용해 문제를 풀 수 있다. 예를 들어 중복된 것을 카운팅 한다던가 등등


3.5) 트리

* 이진트리
1 : 일반트리 > 이진탐색트리(탐색을 빠르게 하기위해 고안됨, 값 : 왼쪽<루트<오른쪽)
2 : 포화이진트리
3 : 완전이진트리 > 최대힙, 최소힙

-> 구현 : 1) 배열(포화이진트리 or 완전이진트리라고 가정)  2) 연결리스트


4) 힙

-> ** 최댓값과 최솟값을 빠르게 찾기 위해 고안된 자료구조
-> 우선순위큐를 구현한 구현체.

- 최대힙 : 부모노드의 키값이 자식 노드의 키값보다 크거나 같은 완전이진트리
- 최소힙 : 부모노드의 키값이 자식 노드의 키값보다 작거나 같은 완전이진트리

* 힙 연산
1 : 삽입  - 최선, 최악 모두 o(logn) 루트노드까지 올라가야하므로 트리의 높이와 같음
2 : 삭제  - 최선, 최악 모두 o(logn) 말단노드까지 내려가야하므로 트리의 높이와 같음

* 구현 : 배열을 이용하여 구현. 완전이진트리이므로 각 노드에 번호를 붙일 수 있음.

* 시간복잡도 : o(logn)

* heapq module
-> 파이썬에서 제공하는 모듈. 일반적인 리스트를 최소힙처럼 다룰 수 있게 해줌.
최대힙은 따로 구현해줘야함

1. 노드 추가 - o(logn)
heap = []
heapq.heappush(heap, 1)

2. 노드 삭제 - o(logn)
a = heapq.heappop(heap)
# peek는 인덱스 0으로 접근.
print(heap[0])

3. 기존에 사용한 리스트를 힙으로 변환하기 : heapify 메소드 이용

시간복잡도는 O(n)

tmp = [7, 5, 8, 3]
heapq.heapify(tmp)

4. 최대 힙 만들기 : 우선순위가 포함된 튜플 이용하기

import heapq

nums = [4, 1, 7, 3, 8, 5]
heap = []

for num in nums:
  heapq.heappush(heap, (-num, num))  # (우선 순위, 값)

while heap:
  print(heapq.heappop(heap)[1])  # index 1


5. 응용 1) k번째 최댓값, 최솟값
-> heappop 함수를 k번 호출하면 됨

6. 응용 2) 힙정렬


```
