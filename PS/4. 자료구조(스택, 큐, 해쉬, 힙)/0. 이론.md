```py

*** 1. 스택

-> LIFO 구조 나중에 들어간 것이 먼저 나온다.

0) init
-> stack = []
1) push
-> stack.append(num)
2) pop
-> a = stack.pop() or stack.pop()
3) peek
-> a = stack[-1]

** 팁

-> 한꺼번에 넣고 생각하지말고 하나씩 넣어보며 조건 판단해보기.
-> 뭔가 연속된 데이터를(연결된 데이터?) 조건에 맞게 차례로 넣을 때 쓸 수 있다.

** 스택에 어떤 특정 데이터를 넣을건지 판단하는 것이 매우 중요. 데이터를 몽땅 넣는 것이 아니라 선택적으로 넣어야함. 예를 들어 후위 표기식 같은 경우는 숫자를 스택에 넣지 않는 것이 훨씬 편함



*** 2. 큐

-> 큐(queue)는 선입선출, FIFO(First In First Out) 기반의 매우 유용한 자료 구조. 큐를 사용하면 데이터를 추가한 순서대로 제거할 수 있기 때문에 스트리밍(streaming), 너비 우선 탐색(breath first search) 에 유용하게 사용할 수 있음

* 파이썬에서 큐 사용방법

1- list

-> enqueue : 뒤 - append() 앞 - insert(0, x)
-> dequeue : 뒤 - pop() 앞 - pop(0)
-> 뒤 : o(1) 앞 : o(N)
-> 한 칸 뒤로 밀어야하기때문
-> 성능면에서 사용하지 않는 것이 좋음. pop(0)과 insert(0, x)는 o(N)이므로 비효율적

2- deque (double-ended queue)

-> collections 모듈의 자료구조.
-> 양방향에서 데이터를 추가하고 제거할 수 있음

-> enqueue : 뒤 - append() 앞 - appendleft()
-> dequeue : 뒤 - pop() 앞 - popleft()
-> 뒤 : o(1) 앞 : o(1)
-> popleft(), appendleft() 는 o(1)이므로 성능대비 이점이 있음






*** 3. 해시

-> 키(Key)와 값(Value)쌍으로 이루어진 데이터 구조를 의미한다. Key를 이용하여 데이터를 찾으므로, 속도를 빠르게 만드는 구조
파이썬에서는 딕셔너리(Dictionary) 타입이 해쉬 테이블과 같은 구조
기본적으로는, 배열로 미리 Hash Table 크기만큼 생성해서 사용한다. 공간은 많이 사용하지만, 시간은 빠르다는 장점이 있음
검색이 많이 필요한 경우, 저장, 삭제, 읽기가 많은 경우, 캐쉬를 구현할 때 주로 사용된다

* 장점
데이터 저장/검색 속도가 빠르다
해쉬는 키에 대한 데이터가 있는지(중복) 확인이 쉽다

* 단점
일반적으로 저장공간이 좀더 많이 필요함
여러 키에 해당하는 주소가 동일할 경우 충돌을 해결하기 위한 별도 자료구조가 필요함. (충돌 해결 알고리즘)

* 시간 복잡도
일반적인 경우(충돌이 없는 경우): O(1)
최악의 경우(모든 경우에 충돌이 발생하는 경우): O(n)

***** 해시는 키 값이 같은 경우 값을 덮어쓴다는 점이 중요. 이를 활용해 문제를 풀 수 있다. 예를 들어 중복된 것을 카운팅 한다던가 등등





*** 3.5. 트리

-> cycle이 없는 그래프(트리가 그래프에 속하는 형태임)

* 이진트리
1 : 일반트리 > 이진탐색트리(탐색을 빠르게 하기위해 고안됨, 값 : 왼쪽<루트<오른쪽)
2 : 포화이진트리
3 : 완전이진트리 > 최대힙, 최소힙

-> 구현 : 1) 배열(포화이진트리 or 완전이진트리라고 가정)  2) 연결리스트






*** 4. 힙(우선순위 큐)

-> ** 최댓값과 최솟값을 빠르게 찾기 위해 고안된 자료구조
-> 우선순위큐를 구현한 구현체.

- 최대힙 : 부모노드의 키값이 자식 노드의 키값보다 크거나 같은 완전이진트리
- 최소힙 : 부모노드의 키값이 자식 노드의 키값보다 작거나 같은 완전이진트리

* 힙 연산
1 : 삽입  - 최선, 최악 모두 o(logn) 루트노드까지 올라가야하므로 트리의 높이와 같음
2 : 삭제  - 최선, 최악 모두 o(logn) 말단노드까지 내려가야하므로 트리의 높이와 같음

* 구현 : 배열을 이용하여 구현. 완전이진트리이므로 각 노드에 번호를 붙일 수 있음.

* 시간복잡도 : o(logn)

* heapq module
-> 파이썬에서 제공하는 모듈. 일반적인 리스트를 최소힙처럼 다룰 수 있게 해줌.
최대힙은 따로 구현해줘야함

1) 노드 추가 - o(logn)
heap = []
heapq.heappush(heap, 1)

2) 노드 삭제 - o(logn)
a = heapq.heappop(heap)
# peek는 인덱스 0으로 접근.
print(heap[0])

3) 기존에 사용한 리스트를 힙으로 변환하기 : heapify 메소드 이용

시간복잡도는 O(n)

tmp = [7, 5, 8, 3]
heapq.heapify(tmp)

4) 최대 힙 만들기 : 우선순위가 포함된 튜플 이용하기

import heapq

nums = [4, 1, 7, 3, 8, 5]
heap = []

for num in nums:
  heapq.heappush(heap, (-num, num))  # (우선 순위, 값)

while heap:
  print(heapq.heappop(heap)[1])  # index 1


5) 응용 1) k번째 최댓값, 최솟값
-> heappop 함수를 k번 호출하면 됨

6) 응용 2) 힙정렬






*** 5. 그래프

$$ 용어 정리 $$

(V,E) = (정점, 간선) = (vertex, edge)

* 방향 그래프 : 방향 간선을 사용, 단방향 통행만 가능 <a,b>
* 무방향 그래프 : 무방향 간선을 사용, 양방향 통행 가능, (a,b)
* 가중치 그래프 : 간선에 비용이나 가중치가 할당된 그래프
* 부분 그래프 : 정점집합 V(G)와 간선집합 E(G)의 부분 집합으로 이루어진 그래프
  - 트리 : 사이클이 없는 그래프
  - 신장트리 : 그래프의 모든 정점을 싸이클 없이 연결하는 그래프
  - 연결그래프 : 무방향 그래프에 있는 모든 정점쌍에 대하여 항상 경로가 존재하는   그래프
* 완전 그래프 : 모든 정점이 연결되어 있는 그래프

* 인접정점 : 하나의 정점에서 간선에 의해 직접 연결된 정점
* 차수 : 하나의 정점에 연결된 다른 정점의 수(무방향 그래프의 모든 차수의 합은 간선 수의 2배)
  - 진입 차수 : (방향그래프) 외부에서 오는 간선의 수
  - 진출 차수 : (방향그래프) 외부로 향하는 간선의 수

* 경로 : 시작점부터 끝 정점까지의 정점들의 나열
  - 단순 경로 : 경로 중에서 반복되는 간선이 없는 경로
  - 사이클 : 단순 경로의 시작 정점과 종료 정점이 동일한 경로


* 그래프 표현 방법

1) 인접행렬방법
- 간선 (i,j)가 그래프에 존재 -> m[i][j] = 1 존재하지 않으면 m[i][j] = 0
- 인접 행렬의 대각선 성분은 모두 0
- 무방향 그래프의 인접 행렬은 대칭
- 인접 행렬에서 간선을 찾는 시간 복잡도는 O(1)이며 어떤 노드의 이웃을 순회하는 시간 복잡도는 O(n)

* 파이썬 인접행렬 표현
a,b,c,d,e,f = range(6)
>>> N = // 방향 그래프
[ a b c d e f
a[0,1,1,1,0,1],
b[1,0,0,1,0,1],
c[1,1,0,1,1,0],
d[1,0,0,0,1,0],
e[1,1,1,0,0,0],
f[0,1,1,1,1,0]
]
>>> N[a][b] // 간선 추가
1
>>> N[a][e] // 간선 삭제
0
>>> sum(N[f]) // 정점의 차수
4

// 가중치 그래프
_ = float('inf')
>>> N = // 방향 가중치 그래프
[
[_,2,1,4,_,1],
[4,_,_,1,_,4],
[1,1,_,2,4,_],
[3,_,_,_,2,_],
[3,4,1,_,_,_],
[1,2,_,4,3,_]
]
>>> N[a][b] # 가중치, weight
2
>>> N[a][b] < _ # 멤버십 테스트
True
>>> sum(1 for w in N[f] if w < _) # 차수
4


2) 인접리스트방법
- 각 정점에 인접한 정점들을 연결리스트로 표현
- 인접 리스트 (adjacency list) 에서는 각 노드에서 이웃 리스트 (셋 또는 컨테이너와 같은 반복 가능 객체) 에 접근할 수 있다. n개의 노드가 있을 때, 각 노드의 인접 (또는 이웃) 리스트는 단순한 숫자 리스트다. 숫자로 노드에 접근 가능한 (인덱싱 가능한) n 개의 메인 리스트에 각 노드의 인접 리스트를 추가하면 된다. 인접 리스트의 추가 순서는 보통 임의적이다.


* 리스트를 사용하여 인접 리스트를 구현할 수도 있다. 이 경우 모든 노드 V에서 N(V)를 효율적으로 순회할 수 있다. 셋을 리스트로 바꾸면 멤버십 테스트의 시간복잡도가 O(n)이 된다 (셋의 경우 평균 시간 복잡도는 O(1), 최악 시간 복잡도는 O(n) 이다). 알고리즘을 수행하는 어떤 작업이 이웃 노드를 반복해서 접근하는 경우 리스트를 사용하는 게 좋을 것이다. 그래프가 촘촘한 경우 (간선이 많은 경우) 에는 셋을 사용하는 게 더 좋다.

* 2-0) 딕셔너리와 리스트 사용 * 제일 많이 사용
graph = {
    'A': ['B'],
    'B': ['A', 'C', 'H'],
    'C': ['B', 'D'],
    'D': ['C', 'E', 'G'],
    'E': ['D', 'F'],
    'F': ['E'],
    'G': ['D'],
    'H': ['B', 'I', 'J', 'M'],
    'I': ['H'],
    'J': ['H', 'K'],
    'K': ['J', 'L'],
    'L': ['K'],
    'M': ['H']
}

2-1) set 을 이용한 인접 리스트 구현

a,b,c,d,e,f = range(6) # 6개 노드
>>> N = [{b,c,d,f}, {a,d,f}, {a,b,d,e}, {a,e}, {a,b,c}, {b,c,d,e}]
>>> b in N[a] # 멤버십 테스트
True
>>> b in N[b]
False
>>> len(N[f]) # 차수
4

2-2) list 를 이용한 인접 리스트 구현

>>> a,b,c,d,e,f = range(6)
>>> N = [[b,c,d,f], [a,d,f], [a,b,d,e], [a,e], [a,b,c], [b,c,d,e]]
>>> b in N[a]
True
>>> b in N[b]
False
>>> len(N[f])
4

2-3) 딕셔너리를 이용한 인접 리스트 구현 -> 간선에 가중치를 줄 수 있음

>>> a,b,c,d,e,f = range(6)
>>> N = [{b:2,c:1,d:4,f:1}, {a:4,d:1,f:4}, {a:1,b:1,d:2,e:4}, {a:3,e:2}, {a:3,b:4,c:1}, {b:1,c:2,d:4,e:3}]
>>> b in N[a]
True
>>> len(N[f])
4
>>> N[a][b] # (a,b)의 간선 가중치, weight
2





* 그래프 탐색

1) DFS

1-1) stack 사용

graph = {
    'A': ['B'],
    'B': ['A', 'C', 'H'],
    'C': ['B', 'D'],
    'D': ['C', 'E', 'G'],
    'E': ['D', 'F'],
    'F': ['E'],
    'G': ['D'],
    'H': ['B', 'I', 'J', 'M'],
    'I': ['H'],
    'J': ['H', 'K'],
    'K': ['J', 'L'],
    'L': ['K'],
    'M': ['H']
}

def dfs(graph, start_node):
  2     visit = list() -> 이미 방문한 노드를 저장하는 visit 변수는 list보다는 dict로 구현하는 것이 탐색시 보다 유리
  3     stack = list()
  4
  5     stack.append(start_node)
  6
  7     while stack:
  8         node = stack.pop()
  9         if node not in visit:
 10             visit.append(node)
 11             stack.extend(graph[node])
 12
 13     return visit

-> 시간복잡도
* 인접행렬 : O(N^2)
* 인접리스트 : O(N+E)

1-2) 재귀 사용

2) BFS

2-1) Queue 사용

2-2) 재귀

-> 시간복잡도
* 인접행렬 : O(N^2)
* 인접리스트 : O(N+E)







```
